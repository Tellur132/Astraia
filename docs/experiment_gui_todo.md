# 実験管理・設定 GUI TODO / プラン

## ゴールと前提
- YAML/CLI 未経験者でも Astraia の実験を「設定→実行→モニタリング→成果物閲覧」まで GUI で完結させる。
- 既存の `astraia` CLI・設定検証 (`OptimizationConfig`)・成果物 (`runs/<id>/...`) を使い回し、実行互換性を保つ。
- LLM キーや実行環境の安全性を損なわず、最小権限で動かす（ローカル優先、外部送信なしが基本）。

## 想定ユーザー / ユースケース
- YAML を直接書きたくない/書けないメンバーが設定値を調整して実行したい。
- 既存 `configs/` のテンプレートを少し変えて試したい（例: メトリクス追加、探索空間の範囲変更）。
- 実行履歴 (`runs/`) を GUI で探して差分・レポートを確認したい。
- API キーを GUI 経由でセット/確認し、`--dry-run` 相当の事前検証をしたい。

## 成功指標 (MVP 時点)
- 主要テンプレート（例: `configs/qgan_kl.yaml`, `configs/quantum/qaoa_llm_guided.yaml` など）を GUI から編集・保存・実行できる。
- 実行前バリデーションでエラー箇所をフィールド単位で表示し、CLI と同等の検証を通過する。
- 実行開始から完了まで GUI 上で状態がわかり、`report.md`/`log.csv` をクリックで開ける。
- LLM キー未設定やネットワーク失敗を GUI で検知し、CLI のエラーメッセージより理解しやすく提示する。

## スコープと段階的リリース
- MVP: ローカル Web UI（シングルユーザー想定）、設定閲覧/編集、`--dry-run` + 実行起動、ステータス閲覧、成果物リンク表示。
- Phase 2: 設定テンプレートの複製/差分表示、`runs diff/compare` の GUI 化、簡易可視化（PNG 埋め込み）。
- Phase 3: ワークスペース共有・権限管理、ジョブキュー、リモート実行先切り替え、LLM プロンプト編集 UX 改善。

## UX / 画面 TODO
- [ ] 初期セットアップ: `.env` のキー有無チェック、必要キー一覧（OpenAI/Gemini）と入力欄、テスト接続ボタン (`--dry-run` に相当)。
- [ ] 設定ブラウザ: `configs/` 配下の一覧、カテゴリやタグ表示、`--summarize` 相当のメタ情報（メトリクス、探索空間、停止条件）を右ペインに表示。
- [ ] 設定エディタ: バリデーション付きフォーム。基本/詳細タブを分け、Pydantic 由来の型・範囲をヒントとして表示。未サポート項目は YAML エディタの「上級者モード」で直接編集。
- [ ] 実行起動フロー: `run_id` 自動生成（編集可）、`--dry-run` 実行→成功時のみ実ジョブ起動。LLM 無効化/有効化の簡易トグル、`max_trials` やサンプラー切り替えなど頻出オプションをクイック設定。
- [ ] 実行モニタリング: 進行中ステータス（`runs status` 情報）をポーリング or SSE で更新。最新トライアルのメトリクス、ログ抜粋、失敗時の理由表示。キャンセルボタン（Graceful 停止対応）。
- [ ] 成果物ビュー: `log.csv` のスパークライン/表、`report.md` の Markdown 表示、PNG グラフ埋め込み。`llm_usage.csv` の集計サマリ（コール数/トークン数/コスト推計）。
- [ ] 実行管理: `runs list` 相当のフィルタ（状態/タグ/日付）、`runs show` 相当のメタデータ表示。Phase 2 以降で `runs diff` と `runs compare` を UI 化。

## 技術・実装 TODO
- [ ] フロントエンド: React/Vite など軽量構成。ローカル前提なので SPA + ローカル API で十分。フォームライブラリで型付き入力（例: React Hook Form + Zod/Pydantic スキーマ鏡像）。
- [ ] バックエンド API: FastAPI / Flask で、既存の `OptimizationConfig` 検証・`astraia` CLI 呼び出しをラップ。`--summarize`/`--as-json`/`--dry-run`/`runs list|show|status|diff|compare` を HTTP 化。
- [ ] プロセス管理: 実行はサブプロセスで CLI を起動し、`runs/<id>/meta.json` の状態変化を監視。中断は SIGINT を送る形で実装（Graceful 停止に合わせる）。
- [ ] 設定の保存先: 既存 `configs/` を直接編集するか、GUI 専用の `configs/gui/` に複製して保存するかを決める（衝突防止策が必要）。
- [ ] バリデーション: バックエンドで `OptimizationConfig.parse_file` を呼び、エラーをフィールド単位にマッピングして返す。YAML 文字位置と Pydantic エラーを突合させるユーティリティを用意。
- [ ] ログ/ストリーミング: 実行中の stdout/stderr を SSE/WebSocket で配信。`log.csv` の先頭/末尾をページング読み込みできる API を用意。
- [ ] 認証/権限: シングルユーザー前提では不要だが、将来マルチユーザーを考えるならトークンベース認証とロール（閲覧のみ/実行可）を設計。
- [ ] LLM キーの扱い: `.env` を直接編集する API は最低限の権限で実装。キーは平文保存になるため、GUI 内で「ローカル保存のみ・Git 管理禁止」の警告を出す。将来的に OS キーチェーン連携を検討。
- [ ] ネットワーク/ファイアウォール考慮: デフォルトは localhost で完結。外部へ送信するのは LLM API のみであることを明示し、プロキシ設定が必要な場合のフックを用意。
- [ ] 配布形態: まずは `uvicorn main:app` での手動起動を想定。次段階で `astraia gui` サブコマンドとして同梱し、起動時にブラウザを開く。

## データモデルと互換性の検討
- `runs/<id>/meta.json` / `config_resolved.json` / `report.md` / `log.csv` を読み取り専用で扱い、破壊的変更を避ける。
- GUI から保存する設定ファイルは `git diff` で追えるよう整形（YAML 出力時にキー順とインデントを固定）。
- `runs status --payload/--tag` に相当する任意メタデータを GUI から付与できるよう JSON スキーマを決める。

## テスト / QA TODO
- [ ] バックエンドの API 単体テスト: 設定検証・dry-run 失敗ケース・ラン起動/キャンセルの擬似テスト。
- [ ] フロントの e2e: テンプレート選択→編集→dry-run→起動→成果物閲覧までを Playwright で自動化（LLM 呼び出しはモック）。
- [ ] 互換性テスト: 既存 CLI で実行した `runs/` を GUI が正しく読み取れるか、逆に GUI で生成した設定を CLI 単体で実行できるかを確認。
- [ ] パフォーマンス: 大きな `log.csv` を扱う際のページング/サマリ生成時間を測定し、閾値を決めて警告する。

## リスクと緩和策
- LLM キー漏洩リスク → `.env` の直接編集は opt-in、キーはマスク表示、ブラウザに保存しない。
- CLI 実行との競合 → 同時起動数を制限し、ジョブごとにワークディレクトリ/ポートを分ける。
- 大きな成果物の描画 → 初期表示はサマリのみ、詳細は遅延ロード。PNG は存在チェック後に表示。
- 設定編集ミス → バリデーションと「実行前 dry-run 強制」をデフォルト ON にする。

## 次のアクション（優先順）
- [ ] MVP のアーキテクチャ決定（ローカル Web UI + FastAPI ラッパーで進めるか、他案がないか合意）。
- [ ] 主要 API 契約を決める（設定一覧/詳細、検証、dry-run、実行開始/停止、実行一覧/詳細、成果物取得）。
- [ ] UI ワイヤーフレーム作成（設定ブラウザ/エディタ、実行ステータス、成果物ビュー）。
- [ ] `astraia` CLI 呼び出しラッパーのプロトタイプ作成（dry-run + 実行 + ログストリーミング）。
- [ ] `.env` 編集/確認フローの安全な実装方針を決める。
